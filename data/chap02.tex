\chapter{问题定义及预备知识}
\label{cha:china}

在这一个章节中，我们首先会对本篇论文所需要阐述的问题，基于大规模空间数据的交互式文本分析进行详细具体的定义。定义将分两步进行，第一步我们将给出交互式分析的问题的具体定义。 第二部我们则基于文本的相关性和空间的相关性来给出文本分析问题的具体定义。然后我们将会具体的讨论关于文本相关性的数值化度量。 在本章节的最后，我们将对现在已经有的一些研究基于大规模空间数据的交互式分析的工作进行介绍和剖析。

\section{基于空间数据的交互式文本分析}
\label{sec:other}

我们首先用符号$D$来表示全体空间文本数据的集合，对于$D$中的每个文本$d$， 我们定义文本$d$由一系列的单词组成，这些单词组成的集合为$W_d$.  同时，每个文本$d$都带有一个数据$L_d$来表示于这个文本相关联的位置信息. 在这个问题当中，每一个给定的一个查询$q$都带有一个指定的查询文档，我们将其称为$D_q$，和一个查询的空间范围，我们称为$S_q$。在这之上，一个文档对于给定查询$q$的文本相关性和空间相关性可以规范化地定义如下：

\begin{definition}
	{\bf 文本相关性}
	
	一个文档$d$能够被称为在文本上和一个查询$q$相关，那么$d$的单词集合$W_d$就必须满足和查询文档$D_q$的单词集合$W_q$相交。 换句话来说，也就是必须有$W_d \cap W_q \ne \phi$. 除了单词集合相交之外，我们还希望文档$D_q$和文档$d$的每个单词在各自文档中出现的频率也是相似的。这种相似程度可以用某种方法来量化，借此来达到对$d$和q文本相关性的量化。 我们将会讨论出一个能够将$d$和q的文本相关性量化的权重函数，这里不妨将其称为$Sim_q(d)$。同时我们将会设置一个文本相关性阈值φ。此时，对于一个给定的查询$q$，一个文档$d$和其文本上相关就可以被定义为$Sim_q(d) < \phi$.
	
\end{definition}

\begin{definition}
	{\bf 空间相关性}
	
	一个文档$d$能够被称为在空间上和一个查询$q$相关，那么$d$的位置信息所代表的空间中的点必须被包含在查询给定的空间范围$S_q$之内。换句话来说，也就是$L_d \in S_q$. 通常来说，$q$的空间范围是一个圆（对于维度为二的空间数据来说），或者是一个广义的球（对于维度为三或者更高的空间数据来说）. 所以，对于这种形式的范围，会有一个中心点$c$和一个半径$r$来定义这个范围。因此，对于一个给定的查询$q$，一个文档$d$和其空间上相关可以被定义为，$q$查询范围$S_q$的中心$c$和文档$d$的位置$L_d$之间的欧拉距离 $dist(c, L_d) < r$.
	
\end{definition}

可以理解，简单来说，基于空间数据的文本分析即为从空间文本数据的全集$D$中寻找特定数据的统计意义上的分析结果，这些数据同时满足空间上和查询$q$相关并且文本上和$q$相关。我们规范地将其定义如下：

\begin{definition}
	{\bf 基于空间数据的文本分析}
	
	基于空间数据的文本分析，即为在全部的空间文本数据中与一个给定查询$q$空间上和文本上都相关的数据进行的统计性的分析并返回分析结果。 不失一般性地，在本篇文章中，我们测试与分析的具体的空间文本分析问题为：在全部的空间文本数据中，统计与一个特定的查询$q$空间上和文本上都相关的数据的总量。该问题可以规范化地定义为:对于一个给定的查询文档$ q $，一个给定的范围半径$ r $以及一个给定的范围中心$ c $，求出满足$ dist(c,L_d) < r \land Sim_q(d) < \phi $的数据点d的数目。
\end{definition}


接下来，我们将引进问题的另一个部分的定义，交互式分析的定义。交互式分析是一种用来应对用户正在与提供分析服务的服务方交互的场景而产生的一种分析类型。 在这样一种特殊的情景下，用户需要的不仅仅只是一个精确的结果，甚至通常他们其实不需要一个精确的结果。他们可以接受只看到一个粗略的估计的结果，但他们希望能够尽可能快地看到这样一个结果。此外，用户在进行交互式分析查询的时候希望自己可以随时更改他们的查询条件而无需等到当前的结果执行完毕。

对于传统的演算精确结果的分析方法， 用户希望在查询中途改变条件而不用等待当前查询执行完毕的话则会陷入一个两难的境地：放弃上一个结果，而快速得到新的结果，或者是让上一个查询与新查询同时运行，这回大大降低新查询的运行速度。实际上，在超大规模的空间文本数据上运行数据分析，得出一个精确的结果需要花的时间通常会超过用户的耐心。为了解决这样一个问题，我们需要一个能够从查询刚开始执行就能不断给用户反馈实时运算结果的分析算法。其中，返回的结果的质量和其运算的时间成正相关。这样的查询算法就可以被规范化定义为交互式查询，如下：

\begin{definition}
	{\bf 交互式分析}
	
交互式分析算法是一种应对用户正在于分析服务交互时采用的算法。具体为，当一个查询到达时，交互式分析算法首先在极短的时间内返回一个非常粗略的结果给用户。接下来，交互式分析算法将持续地计算结果，并实施的将最新的计算结果更新并呈现给用户。计算结果将随着时间的增长而变得越来越接近精确结果。

\end{definition}


\section{文本相关性的衡量与量化}
\label{sec:other}
到目前为止，已经出现了许许多多的模型(例如说向量空间模型，概率模型，语言模型，等等)来衡量一个特定文本和一个给定查询的文本相关性。在所有的这些模型中，属向量空间模型被使用最为广泛。

通常来说，在文本分析当中，我们会从所有在全部文档内出现过的词语组成的集合中，筛掉一些无意义词汇，将有意义的词语挑选出来做为索引词语。一般那些出现太过频繁的词语，比如我，的，了等等，以及那些仅在极个别篇文档中出现过的词语都不会被挑选为索引词汇。

在向量空间模型中，每一个索引词$k_i$与文档$d$构成的组合都会被分配上一个权重$W_(i,d)$。这里的$W_(i,d)$必须是非负数并且不是一个二分的值（(即取值只有两种可能)。每一个索引词汇与查询所构成的组合也会被分配到一个权重。$W_(i,q)$则表示索引词汇$k_i$与查询$q$的组合所对应的权重。

通过使用这样一权重，我们可以将每一个文档$d$表示成一个向量$\vec{d} = (w_(1,d),w_(2,d)\dots w_(t,d)),$。其中t是在这个文本系统中索引词汇的总数。同样地，一个查询所对应的的查询文档也可以被表示成一个向量的形式$\vec{q} = (w_(1,q),w_(2,q)\dots w_(t,q)),$

因此，在向量模型当中，每一个文档$d$和每一个用户查询$q$都可以被表示成一个$t$维度的向量。这些向量能用来帮助我们测量特定文档与特定查询之间的相似程度。方法就是计算向量$\vec{d}$和向量$\vec{q}$的关联。

不失一般性地，我们对于向量空间模型里一般性的概念做出如下规定，使其成为一个具体的问题。对于一个特定的索引词与一个特定的文档，我们使用该索引词在该文档中出现的频率来作为他们之间的权重。换句话来说，也就是$W_(i,d) = TF_(i,d)$。其中TF即Term Frequency也即词频，$TF_(i,d)$表示特定的索引词$k_i$出现在文章$d$中的次数。而我们之前所提到的文本相关性的量化函数$Sim_q(d)$则可以直接用向量$\vec{d}$和向量$\vec{q}$来计算。具体为向量$\vec{d}$和向量$\vec{q}$的夹角的cos值。所以我们得到以下公式：



\begin{equation}
\begin{split}
Sim(d_i,q)&= \frac{\vec{d} \bullet \vec{q}}{|\vec{d}| \times |\vec{q}|}\\
&=\frac{\sum_{i=1}^{t}W_(i,d) \times W_(i,q)}{\sqrt{\sum_{i=1}^{t}W_(i,d)^2} \times \sqrt{\sum_{j=1}^{t}W_(j,q)^2}}
\end{split}
\end{equation}

\section{交互式分析领域的现状及前沿工作}

在这一个部分我们将详细介绍一些可以用来解决大规模空间数据上的交互式分析的研究。这些前沿的工作将可以被用作一个对比算法来评估我们新算法的表现。

\subsection{在线采样与聚集}

首先我们将引入一个用来解决交互式问题的重要概念，在线采样与聚集。在线采样算法是解决在超大数据集上进行交互式分析的一个重要基石，同时也是一个非常高效的近似算法。在线采样与聚集算法与传统的一些先对查询的与其花费时间进行评估，再针对用户需求运行不同复杂度的算法的方法不同，它并不需要对用户或者查询做任何预期。它只需要不停地从所有满足查询条件的数据中取出样本，然后连续不断地计算目前已经取得的样本的集合而成的统计分析结果。

在线采样与聚集算法的理论可行性，即使用样本的统计数据来估计整体的统计数据已经在统计学理论中得到了强有力的支持。 这使得在线采样与聚集算法在那些不要求精确结果的计算分析中得到了十分广泛的应用。事实上，使用随机的样本来处理近似的查询在数据库中已经有了相当长的历史。可以明显地看到在数据库领域有关在线聚集的研究非常之多。在这一类的算法中，我们计算的聚合的结果的准确率将会不断地提升随着我们获得越来越多的样本，这一准确率是通过置信区间的理论来计算的。而用户可以在自己认为准确率已经达到自己能够满意的标准的时候随时终止查询算法。

近段时期，在线采样与聚集算法又重新燃起了研究者们的热情。因为在大数据时代，这是一个十分高效的工具用以支持回答基于超大数据上的大型查询。就需求而言，大部分场景下，这一类查询的用户通常可以满足于这一算法通过聚合产生的大致精确的估计结果。

\subsection{R树}
R树是一个相当传统经典同时很受欢迎的用来处理多维空间数据的索引结构。R树经常被用来回答一些空间范围查询，例如说，计算在指定的区域内的数据点的个数。R树在结构上和B树非常的相似。所有的数据点都被储藏在了叶子节点，所有的中间节点都会存有包含该节点所有子孙节点的最小包围盒（）最小包围盒即为一个体积最小的，同时能够包含所有给定点的盒子）。

要在R树上回答一个范围查询 $Q$，算法将从R树的根节点开始，自顶向下遍历R树。对于那些最小包围盒完全被查询范围包含的节点，直接报告；对于那些最小包围盒与查询范围相交，但又不被查询范围包含的节点，继续向下访问其所有子节点来寻求答案；而对于那些最小包围盒与查询范围完全不相交的节点，则直接略过。

\subsection{LS树}
LS树~\cite{RS}是一种数据索引结构专门用来解决基于空间数据上的在线采样与聚集问题。LS树的算法是在R树的基础上衍生出来的。实际上，LS树就由一系列的R树组成。

该算法现在规定一个集合序列$ S $，第一个集合$ S_{0}= $所有数据的全集。然后该算法将递推地对这个集合序列进行构造。在构造出$ S_{i} $之后，该算法通过从集合$ S_{i} $中用随机采样点方式，以50\%的概率取出一个数据样本的集合，这个数据样本的集合即为$ S_{i+1} $. 该算法重复这样的构造，直到该算法构造出的最新的集合$ S_{l} $的大小小于等于一个设定好的常数。

在该算法刚才构造的集合序列之上，该算法将基于每一个集合$ S_{i} $分别构造一个R树$ T_{i} $，（$ i = 0,1,2 \dots l $）。由于该算法集合构造的条件为最后的集合有一个常数的大小，假设我们的数据量是$ N $，那么该算法将会构造$ O(log(N)) $的R树，他们所占用的总大小复杂度为$ O(N) $。

对于每一个查询Q，算法只需要按$ T_{l},T_{l-1} \dots T_{1} $的顺序依次对每个R树进行普通的R树查询算法即可。由于前面的构造，我们可以发现在这里面的一棵树$ T_{i} $上查询得到的点实际上可以认为是查询所需要的目标数据全集的一个概率为$ \frac{1}{2^i} $的一个数据样本。这样按照倒序顺序在每棵树上运行普通的R树查询，该算法将得到一堆的基于重置抽样的样本点。

若要得到基于不重置抽样的样本点，根据~\cite{RS07}的理论，对重置抽样的样本点进行一个随机置换即可将其转化为不重置抽样的样本点。该算法会将取到的样本不断地报告给用户，直到用户下令终止查询或者所有的样本取完，即访问到最后一颗树为止。当算法执行完一颗R树的查询，移到下一颗R树的时候，因为$ S_{i} \subset S_{i+1} $,所以前一棵树产生的样本会再一次地被现在这棵树所查到。若要转化为不重置抽样的样本点，需要维护一个已报告样本点的集合，以保证样本不会被重复报告。

\subsection{RS树}
RS树是到目前为止在空间数据查询上最为高效的在线采样与聚集算法。RS树也是一个基于R树的索引结构。与LS树不同的是，RS树是直接在一棵R树上进行改造。对于R树种的每一个中间节点，RS树将会设立一个样本缓冲区并将其附到节点上。

在样本缓冲区中，所有的样本点都是有重置地从缓冲区所在节点的子树中随机采样出来的样本。这些缓冲区在RS树刚开始构建的时候都有一个常数的大小$ s $。对于那些子树中数据数量小于$ s $的节点，缓冲区将不会被建立。在RS树动态变化的过程中，也就是对RS树进行添加和删除操作的时候，缓冲区的大小也会发生改变。但缓冲区会通过分裂与合并的方式来将缓冲区的大小维持在$ s/2 $与$ s $之间。

应对一个范围查询$ Q $的时候，RS树首先将会从树的根节点开始，访问根节点的缓冲区，并将其中符合要求在查询范围内的点报告上去。此后，从根节点开始，向下遍历。每次在完成对一个节点缓冲区的访问以后，RS树将会继续访问该节点的子节点中与查询范围相交的那些节点。具体做法是，RS树在查询开始就维护一个想要采样的节点的列表。在初始化的时候，唯一存在这个列表中的节点就是根节点。接下来，RS树将会不断重复以下步骤：

\begin{enumerate}
\item 从列表中随机取出一个节点$ u $，每个节点被取出的概率和该节点子树中有效的数据量成正比。

\item 在节点$ u $被选出来之后，如果该节点有缓冲区，从该节点的缓冲区中未取过的样本中在取出一个样本，如果该样本在查询范围内，则报告该样本。如果该节点没有缓冲区，则从以该节点为根节点的子树中有重置地随机抽取出一个数据点进行检查，若该数据点在查询范围之内，则报告。

\item 在上一步骤结束之后，如果节点$ u $有缓冲区且所有样本均已取过，节点$ u $将会被从列表中移出。同时节点$ u $的子节点中，最小包围盒与查询范围相交的将会被加入到列表当中。

\item 回到步骤(1)
\end{enumerate}



注意到当访问到的节点没有缓冲区时，我们会从节点的子树中有重置的抽取样本。因此这个算法是不会停止的，它会持续地报告符合要求的节点直到用户将查询终结。















